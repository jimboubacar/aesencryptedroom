/*
 CLASS: CryptoUtil
 PURPOSE:
 Provides AES/GCM/NoPadding encryption + decryption using a key stored in the Android Keystore.
 Produces and consumes strings in the form:  Base64(IV) + ":" + Base64(ciphertext+tag).

 HOW TO USE:
 To encrypt plaintext:  String ct = CryptoUtil.encryptToBase64IvCt("my secret");
 Store 'ct' (e.g., in Room). It contains a provider-generated IV and the GCM ciphertext.
 To decrypt later:      String pt = CryptoUtil.decryptFromBase64IvCt(ct);
 Returns the original plaintext, provided the keystore key still exists and data wasn't tampered with.

 NOTES:
 The IV is generated by the crypto provider on ENCRYPT and read back via cipher.getIV().
 If the keystore entry is missing/invalidated (e.g., app reinstalled), old ciphertext cannot be decrypted.
 Set FORCE_128_BIT=true if your emulator refuses 256-bit AES keys.
 */

package com.example.aesencryptedroom;                       // Package for the app's classes

import android.security.keystore.KeyGenParameterSpec;       // For specifying how the keystore key is generated
import android.security.keystore.KeyProperties;             // Constants for key purposes, modes, paddings
import android.util.Base64;                                 // Base64 encoding/decoding for IV and ciphertext
import android.util.Log;                                    // Logging for diagnostics

import java.nio.charset.StandardCharsets;                   // UTF-8 encoding for strings
import java.security.KeyStore;                              // AndroidKeyStore access

import javax.crypto.Cipher;                                 // Cryptographic cipher API
import javax.crypto.KeyGenerator;                           // To generate a symmetric AES key
import javax.crypto.SecretKey;                              // The AES key type
import javax.crypto.spec.GCMParameterSpec;                  // Supplies IV + tag length for GCM on decrypt

public class CryptoUtil {                                   // Utility class with static crypto helpers
    private static final String TAG = "CryptoUtil";         // Log tag
    private static final String ANDROID_KEYSTORE = "AndroidKeyStore"; // Keystore provider name
    private static final String KEY_ALIAS = "room_aes_gcm_key";       // Alias under which the key is stored
    private static final String TRANSFORMATION = "AES/GCM/NoPadding"; // Cipher transformation used
    private static final int GCM_TAG_LENGTH_BITS = 128;     // Auth tag length for GCM (recommended 128 bits)
    private static final boolean FORCE_128_BIT = false;     // Flip to true if 256-bit is unsupported by device

    private static SecretKey getKey(boolean recreate) throws Exception { // Create or fetch the AES key
        KeyStore ks = KeyStore.getInstance(ANDROID_KEYSTORE); // Open Android Keystore
        ks.load(null);                                        // Load keystore (no password for app keystore)

        if (recreate && ks.containsAlias(KEY_ALIAS)) {        // If asked to recreate and key exists…
            ks.deleteEntry(KEY_ALIAS);                        // …delete old entry
        }

        if (ks.containsAlias(KEY_ALIAS)) {                    // If key already present…
            KeyStore.SecretKeyEntry entry =
                    (KeyStore.SecretKeyEntry) ks.getEntry(KEY_ALIAS, null); // …read it
            return entry.getSecretKey();                      // …and return
        }

        KeyGenerator gen = KeyGenerator.getInstance(          // Prepare generator for AES inside Keystore
                KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEYSTORE);
        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(
                KEY_ALIAS,                                    // Store under this alias
                KeyProperties.PURPOSE_ENCRYPT |               // Allow encrypt…
                        KeyProperties.PURPOSE_DECRYPT                 // …and decrypt
        )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)  // Use GCM mode
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE) // No padding with GCM
                .setRandomizedEncryptionRequired(true)        // Require fresh randomness (IV) per encryption
                .setKeySize(FORCE_128_BIT ? 128 : 256)        // Choose key size (256 by default)
                .build();                                     // Build the spec

        gen.init(spec);                                       // Initialise generator with spec
        return gen.generateKey();                             // Create and return the new key
    }

    private static SecretKey healthyKey() throws Exception {  // Fetch a usable key; recreate on failure
        try { return getKey(false); }                         // Try to get existing key
        catch (Throwable t) {                                 // If anything goes wrong…
            Log.w(TAG, "Key fetch failed, recreating: " + t); // …log and
            return getKey(true);                              // …recreate the key
        }
    }

    /** Returns Base64(IV) + ":" + Base64(CT) */              // Public API: encrypt to IV:CT string
    public static String encryptToBase64IvCt(String plaintext) {
        if (plaintext == null) return null;                   // Null-in, null-out for convenience
        try {
            Cipher cipher = Cipher.getInstance(TRANSFORMATION); // Get AES/GCM cipher
            cipher.init(Cipher.ENCRYPT_MODE, healthyKey());   // ENCRYPT_MODE; provider generates the IV
            byte[] ct = cipher.doFinal(                       // Encrypt UTF-8 bytes
                    plaintext.getBytes(StandardCharsets.UTF_8));
            byte[] iv = cipher.getIV();                       // Read provider-generated IV

            String ivB64 = Base64.encodeToString(iv, Base64.NO_WRAP); // Base64 encode IV (no line breaks)
            String ctB64 = Base64.encodeToString(ct, Base64.NO_WRAP); // Base64 encode ciphertext+tag
            return ivB64 + ":" + ctB64;                       // Return canonical "IV:CT" form
        } catch (Exception e) {                               // Any crypto/provider error
            Log.e(TAG, "Encryption failed", e);               // Log full stack
            throw new RuntimeException(                       // Surface a concise message up the stack
                    "Encryption failed: " + e.getClass().getSimpleName() +
                            (e.getMessage() != null ? (": " + e.getMessage()) : ""), e);
        }
    }

    public static String decryptFromBase64IvCt(String encoded) { // Public API: decrypt from IV:CT string
        if (encoded == null) return null;                     // Null-in, null-out
        try {
            String[] parts = encoded.split(":");              // Split into IV and CT
            if (parts.length != 2)                            // Validate format
                throw new IllegalArgumentException("Bad ciphertext format");
            byte[] iv = Base64.decode(parts[0], Base64.NO_WRAP); // Decode IV
            byte[] ct = Base64.decode(parts[1], Base64.NO_WRAP); // Decode ciphertext+tag

            Cipher cipher = Cipher.getInstance(TRANSFORMATION); // Get AES/GCM cipher
            cipher.init(                                       // DECRYPT_MODE with IV + tag length
                    Cipher.DECRYPT_MODE, healthyKey(),
                    new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv));
            byte[] pt = cipher.doFinal(ct);                   // Decrypt + authenticate (throws if tampered)
            return new String(pt, StandardCharsets.UTF_8);    // Convert bytes back to UTF-8 string
        } catch (Exception e) {                               // Handle format/keystore/auth failures
            Log.e(TAG, "Decryption failed", e);               // Log full stack
            throw new RuntimeException(                       // Propagate concise message
                    "Decryption failed: " + e.getClass().getSimpleName() +
                            (e.getMessage() != null ? (": " + e.getMessage()) : ""), e);
        }
    }

    public static String quickSelfTest() {                    // Simple sanity check for dev/testing
        try {
            String ct = encryptToBase64IvCt("hello");         // Encrypt a known string
            String pt = decryptFromBase64IvCt(ct);            // Decrypt it back
            return "Self-test OK (" +                         // Report success + key size used
                    (FORCE_128_BIT ? "AES-128" : "AES-256") + "), PT=" + pt;
        } catch (Throwable t) {                               // If anything fails, return message
            return "Self-test FAILED: " + t.getMessage();
        }
    }
}
